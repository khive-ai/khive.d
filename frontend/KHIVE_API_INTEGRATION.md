# KHIVE API Integration Documentation\n\n## Overview\n\nThis document describes the KHIVE daemon API integration architecture for Ocean's Command Center frontend. The integration provides real-time communication with the KHIVE orchestration backend through both HTTP REST APIs and WebSocket connections.\n\n## Architecture\n\n```\n┌─────────────────────────────────────┐\n│           Frontend App              │\n├─────────────────────────────────────┤\n│  Components (CommandCenter, etc.)   │\n├─────────────────────────────────────┤\n│         useKhiveWebSocket           │  ← Main Integration Hook\n├─────────────────────────────────────┤\n│  KhiveApiService  │ WebSocketService │  ← Service Layer\n├─────────────────────────────────────┤\n│      HTTP Client   │   Socket.io     │  ← Protocol Layer\n├─────────────────────────────────────┤\n│         KHIVE Daemon Backend        │\n└─────────────────────────────────────┘\n```\n\n## Core Components\n\n### 1. KhiveApiService (`/lib/services/khiveApiService.ts`)\n\n**Purpose**: HTTP REST API client for KHIVE daemon communication\n\n**Key Features**:\n- Protocol-design principles implementation\n- Comprehensive error handling with custom error types\n- Retry logic for connection failures\n- Type-safe API methods\n\n**Error Types**:\n```typescript\nKhiveApiError        // API-level errors (4xx, 5xx responses)\nKhiveConnectionError // Network-level errors (connection refused, timeout)\n```\n\n**Main Methods**:\n- `getDaemonStatus()` - Get daemon health and status\n- `submitPlan(request)` - Submit planning requests\n- `getSessions()` - Fetch orchestration sessions\n- `executeCommand(command, args, priority)` - Execute KHIVE commands\n- `spawnAgent(role, domain, coordinationId)` - Spawn new agents\n- `getCoordinationEvents(coordinationId)` - Get coordination events\n\n### 2. KhiveWebSocketService (`/lib/services/khiveWebSocketService.ts`)\n\n**Purpose**: Real-time WebSocket communication with KHIVE daemon\n\n**Protocol Features**:\n- Connection state management with exponential backoff\n- Message deduplication using sliding window (30s window, 1000 message buffer)\n- Health monitoring with latency tracking\n- Automatic reconnection with circuit breaker pattern\n- Message queuing for offline resilience (max 100 messages)\n- Ping/pong for connection health (5s intervals)\n\n**Event Types**:\n```typescript\n// Outbound (client → server)\njoin_coordination(coordinationId)\nsubscribe_session(sessionId) \nping()\n\n// Inbound (server → client)\ncoordination_event(event)\nsession_updated(session)\nagent_updated(agent)\ndaemon_status_updated(status)\n```\n\n### 3. useKhiveWebSocket Hook (`/lib/hooks/useKhiveWebSocket.ts`)\n\n**Purpose**: React hook that combines HTTP API and WebSocket for complete integration\n\n**Features**:\n- Automatic daemon status polling (5s intervals)\n- Session data fetching with real-time updates\n- WebSocket connection management\n- Error boundary and state synchronization\n- TanStack Query integration for caching\n\n**Return Interface**:\n```typescript\ninterface WebSocketState {\n  // Connection state\n  connected: boolean;\n  error: string | null;\n  connectionHealth: ConnectionHealth;\n  stats: WebSocketStats;\n  \n  // Data state\n  sessions: OrchestrationSession[];\n  events: CoordinationEvent[];\n  agents: Agent[];\n  daemonStatus: DaemonStatus;\n  \n  // Actions\n  sendCommand: (command: string, priority?: number) => Promise<boolean>;\n  reconnect: () => Promise<void>;\n  joinCoordination: (coordinationId: string) => void;\n  subscribeToSession: (sessionId: string) => void;\n}\n```\n\n## Configuration\n\n### Environment Variables\n```bash\nNEXT_PUBLIC_KHIVE_API_URL=http://localhost:8000    # REST API base URL\nNEXT_PUBLIC_KHIVE_WS_URL=ws://localhost:8767       # WebSocket URL\n```\n\n### KHIVE_CONFIG (`/lib/config/khive.ts`)\n```typescript\nconst KHIVE_CONFIG = {\n  API_BASE: 'http://localhost:8000',\n  WEBSOCKET_URL: 'ws://localhost:8767',\n  \n  POLLING: {\n    DAEMON_STATUS_INTERVAL_MS: 5000,\n    SESSION_UPDATE_INTERVAL_MS: 1000,\n  },\n  \n  UI: {\n    COMMAND_RESPONSE_TIME_MS: 100,\n    MAX_ACTIVITY_STREAM_ITEMS: 1000,\n  }\n};\n```\n\n## Usage Examples\n\n### 1. Using the Hook in Components\n\n```typescript\nimport { useKhiveWebSocket } from '@/lib/hooks/useKhiveWebSocket';\n\nfunction CommandCenter() {\n  const { \n    connected, \n    sessions, \n    events, \n    daemonStatus, \n    sendCommand,\n    joinCoordination \n  } = useKhiveWebSocket();\n  \n  // Join coordination room for real-time updates\n  useEffect(() => {\n    if (coordinationId) {\n      joinCoordination(coordinationId);\n    }\n  }, [coordinationId, joinCoordination]);\n  \n  const handleCommand = async (command: string) => {\n    const success = await sendCommand(command, 1); // priority 1 = normal\n    if (success) {\n      console.log('Command executed successfully');\n    }\n  };\n  \n  return (\n    <div>\n      <div>Status: {connected ? 'Connected' : 'Disconnected'}</div>\n      <div>Daemon: {daemonStatus.running ? 'Running' : 'Stopped'}</div>\n      <div>Sessions: {sessions.length}</div>\n      <div>Recent Events: {events.slice(0, 10)}</div>\n    </div>\n  );\n}\n```\n\n### 2. Direct API Service Usage\n\n```typescript\nimport { KhiveApiService } from '@/lib/services/khiveApiService';\n\n// Planning request\nconst planResponse = await KhiveApiService.submitPlan({\n  task_description: \"Implement user authentication\",\n  complexity: \"medium\",\n  pattern: \"P→\", // Sequential pipeline\n  max_agents: 5\n});\n\n// Spawn agent\nconst spawnResult = await KhiveApiService.spawnAgent(\n  'implementer',\n  'protocol-design', \n  planResponse.coordination_id,\n  'Implement OAuth2 integration'\n);\n\n// Get coordination events\nconst events = await KhiveApiService.getCoordinationEvents(\n  planResponse.coordination_id, \n  50 // limit\n);\n```\n\n### 3. WebSocket Service Direct Access\n\n```typescript\nimport { khiveWebSocketService } from '@/lib/services/khiveWebSocketService';\n\n// Manual connection management\nawait khiveWebSocketService.connect();\n\n// Subscribe to events\nkhiveWebSocketService.on('coordination_event', (event) => {\n  console.log('Coordination event:', event);\n});\n\n// Join coordination room\nkhiveWebSocketService.joinCoordination('coord_123');\n\n// Get connection health\nconst health = khiveWebSocketService.getConnectionHealth();\nconsole.log('Latency:', health.latency, 'ms');\n```\n\n## Error Handling\n\n### Protocol-Level Error Handling\n\n```typescript\ntry {\n  const status = await KhiveApiService.getDaemonStatus();\n} catch (error) {\n  if (error instanceof KhiveConnectionError) {\n    // Network issues - show retry button\n    console.log('Connection failed, retryable:', error.retryable);\n  } else if (error instanceof KhiveApiError) {\n    // API errors - show error message\n    console.log('API error:', error.status, error.message);\n  }\n}\n```\n\n### WebSocket Error Handling\n\n```typescript\nconst { error, connectionHealth } = useKhiveWebSocket();\n\n// Display connection status\nif (error) {\n  return <ErrorBanner message={error} />;\n}\n\nif (connectionHealth.status === 'unhealthy') {\n  return <WarningBanner message=\"Poor connection quality\" />;\n}\n```\n\n## Testing\n\n### Integration Tests\n\nLocation: `/src/__tests__/integration/khive-api-integration.test.ts`\n\n**Test Coverage**:\n- API service methods\n- WebSocket connection handling\n- Error scenarios\n- Configuration validation\n- Hook behavior\n\n**Running Tests**:\n```bash\nnpm test                      # Run all tests\nnpm test -- --watch          # Watch mode\nnpm test -- --coverage       # With coverage\n```\n\n### Mocking for Component Tests\n\n```typescript\n// Mock the hook for component testing\njest.mock('@/lib/hooks/useKhiveWebSocket', () => ({\n  useKhiveWebSocket: () => ({\n    connected: true,\n    sessions: [],\n    events: [],\n    daemonStatus: { running: true, health: 'healthy' },\n    sendCommand: jest.fn().mockResolvedValue(true),\n    joinCoordination: jest.fn(),\n  })\n}));\n```\n\n## Performance Considerations\n\n### Connection Management\n- WebSocket auto-reconnection with exponential backoff\n- Message queuing prevents loss during temporary disconnections\n- Duplicate message filtering reduces redundant processing\n- Connection health monitoring for proactive issue detection\n\n### Data Synchronization\n- TanStack Query for intelligent caching and background updates\n- Real-time WebSocket updates invalidate cached data when needed\n- Event buffering limits memory usage (1000 events max)\n- Polling intervals optimized for responsiveness vs. resource usage\n\n### Error Resilience\n- Retry logic for transient network errors\n- Circuit breaker pattern prevents cascading failures\n- Graceful degradation when WebSocket is unavailable\n- Offline queue ensures commands aren't lost\n\n## Security Considerations\n\n### HTTP Client Security\n- Credentials included for authentication (`credentials: 'same-origin'`)\n- Content-Type validation\n- Input sanitization for API requests\n- CORS handling\n\n### WebSocket Security\n- Connection over WSS in production\n- Event validation and sanitization\n- Rate limiting through message queuing\n- Proper cleanup of event listeners\n\n## Troubleshooting\n\n### Common Issues\n\n1. **\"Connection refused\" errors**\n   - Check if KHIVE daemon is running on correct port\n   - Verify API_BASE URL in configuration\n   - Ensure network connectivity\n\n2. **WebSocket connection failures**\n   - Check WEBSOCKET_URL configuration\n   - Verify firewall settings for WebSocket traffic\n   - Monitor browser console for detailed error messages\n\n3. **High latency or poor performance**\n   - Check connection health metrics\n   - Monitor message queue size\n   - Verify polling intervals aren't too aggressive\n\n4. **Missing real-time updates**\n   - Ensure coordination room is joined properly\n   - Check WebSocket connection status\n   - Verify event listeners are registered\n\n### Debug Mode\n\n```typescript\n// Enable debug logging\nkhiveWebSocketService.on('error', console.error);\nkhiveWebSocketService.on('connect', () => console.log('Connected'));\nkhiveWebSocketService.on('disconnect', (reason) => console.log('Disconnected:', reason));\n\n// Monitor connection health\nsetInterval(() => {\n  const health = khiveWebSocketService.getConnectionHealth();\n  const stats = khiveWebSocketService.getStats();\n  console.log('Health:', health, 'Stats:', stats);\n}, 5000);\n```\n\n## Future Enhancements\n\n1. **Authentication Integration**\n   - JWT token management\n   - Automatic token refresh\n   - Role-based access control\n\n2. **Advanced Features**\n   - Message compression for large payloads\n   - Binary protocol support for high-frequency data\n   - Multi-region failover\n   - Metrics dashboard integration\n\n3. **Developer Experience**\n   - GraphQL integration option\n   - Auto-generated API client from OpenAPI spec\n   - Enhanced debugging tools\n   - Performance monitoring dashboard