---
title: "Implementation Plan: FastMCP Migration - Critical Architectural Refactor"
issue: 152
type: "CRITICAL_REFACTOR"
priority: "P0 - BLOCKING"
created: "2025-05-24"
assignee: "@khive-implementer"
reviewer: "@khive-reviewer"
status: "IN_PROGRESS"
---

## Executive Summary

**CRITICAL ARCHITECTURAL DEBT RESOLUTION**: Replace 262-line custom MCP implementation with FastMCP library to align with Khive's core principle "tools should unify, not multiply." This refactor will reduce codebase by ~400 lines while improving maintainability and test coverage.

## Problem Statement

Quality review identified fundamental violation of Khive principles:
- Custom JSON-RPC 2.0 implementation reinventing MCP wheel
- 262 lines in `mcp_client.py` that should be ~20 lines with FastMCP
- Test isolation broken with real MCP server connections
- Coverage dropped to 5% (required: 80%+)
- CI failures blocking Session 002

## Technical Approach

### Phase 1: Research & Dependencies
1. **Research FastMCP Library**
   - Investigate FastMCP API and capabilities
   - Identify equivalent patterns for current functionality
   - Understand testing utilities and mock support

2. **Add FastMCP Dependency**
   ```bash
   uv add fastmcp
   ```

### Phase 2: Core Implementation Replacement

#### 2.1 Replace MCPClient Class
**Current**: 262-line custom implementation in `src/khive/adapters/mcp_client.py`
**Target**: FastMCP-based implementation with decorators

**Key Changes**:
- Replace `MCPClient` class with FastMCP client
- Use `@tool` and `@resource` decorators where applicable
- Eliminate manual JSON-RPC 2.0 protocol handling
- Preserve existing CLI interface and functionality

#### 2.2 Update Configuration Handling
**Current**: Custom `MCPServerConfig` and `MCPConfig` classes
**Target**: FastMCP configuration patterns

**Preserve**:
- `.khive/mcps/config.json` format compatibility
- All CLI arguments and behavior
- Server discovery and management

#### 2.3 Maintain Adapter Interface
**Files to Update**:
- `src/khive/adapters/mcp_server_adapter.py`
- `src/khive/adapters/mcp_discovery_adapter.py`
- `src/khive/cli/khive_mcp.py`

**Constraints**:
- Keep same CLI interface (`khive mcp list|status|tools|call`)
- Preserve all existing functionality
- Maintain configuration compatibility

### Phase 3: Test Infrastructure Overhaul

#### 3.1 Fix Test Isolation
**Problem**: Tests connecting to real MCP servers
**Solution**: Use FastMCP's mock utilities

**Target Files**:
- `tests/adapters/test_mcp_adapters.py`
- Any integration tests using MCP

**Requirements**:
- Mock all MCP server interactions
- Test both success and failure paths
- Achieve 80%+ coverage

#### 3.2 Add Comprehensive Test Coverage
**Test Categories**:
- Unit tests for new FastMCP integration
- Integration tests with mocked servers
- CLI command tests with proper isolation
- Error handling and edge cases

### Phase 4: Quality Gates

#### 4.1 CI Fixes
- Resolve 3 failing tests
- Achieve 80%+ test coverage
- Fix test isolation issues

#### 4.2 Deprecation Warnings
- Fix Pydantic deprecation issues
- Update validation patterns

#### 4.3 Code Quality
- Run `khive fmt` and `khive ci`
- Ensure all pre-commit hooks pass
- Maintain type safety

## Implementation Steps

### Step 1: Research FastMCP (30 min)
```bash
# Research FastMCP library
khive info search --provider perplexity --query \
  "FastMCP Python library documentation API reference MCP protocol \
   implementation with decorators tools resources testing utilities 2024-2025"
```

### Step 2: Add Dependency (5 min)
```bash
uv add fastmcp
```

### Step 3: Implement FastMCP Client (2 hours)
1. Create new FastMCP-based implementation
2. Replace `MCPClient` class
3. Update imports and usage

### Step 4: Update Adapters (1 hour)
1. Update `mcp_server_adapter.py`
2. Update `mcp_discovery_adapter.py`
3. Ensure CLI compatibility

### Step 5: Fix Tests (2 hours)
1. Replace real server connections with mocks
2. Add comprehensive test coverage
3. Achieve 80%+ coverage target

### Step 6: Quality Validation (30 min)
```bash
khive ci                    # Run all tests
khive fmt                   # Format code
uv run pre-commit run --all-files
```

## Success Criteria

### Functional Requirements
- [ ] All existing CLI commands work identically
- [ ] Configuration format unchanged
- [ ] Server discovery and management preserved
- [ ] Error handling maintained

### Quality Requirements
- [ ] 80%+ test coverage achieved
- [ ] All CI tests passing
- [ ] No real MCP server connections in tests
- [ ] Pydantic deprecation warnings resolved

### Architectural Requirements
- [ ] Custom MCP implementation eliminated
- [ ] FastMCP library properly integrated
- [ ] Codebase reduced by ~400 lines
- [ ] Khive principles upheld

## Risk Mitigation

### High Risk: API Compatibility
**Risk**: FastMCP API might not support all current features
**Mitigation**: Research thoroughly, maintain compatibility layer if needed

### Medium Risk: Test Complexity
**Risk**: FastMCP testing patterns might be complex
**Mitigation**: Start with simple test cases, build up complexity

### Low Risk: Configuration Changes
**Risk**: FastMCP might require different configuration
**Mitigation**: Maintain compatibility layer for existing configs

## Dependencies

### External
- FastMCP library availability and stability
- FastMCP testing utilities

### Internal
- No circular dependencies
- Clean separation of concerns

## Timeline

**Total Effort**: 6 hours
- Research: 30 min
- Implementation: 3 hours
- Testing: 2 hours
- Quality validation: 30 min

**Completion Target**: Same day (critical priority)

## Validation Commands

```bash
# Test the refactor
khive mcp list
khive mcp status filesystem
khive mcp tools filesystem
khive mcp call filesystem read_file --path README.md

# Quality checks
khive ci
khive fmt
uv run pytest tests/ --cov=src --cov-report=term
```

## References

- **Quality Review**: `.khive/reports/crr/CRR-001.md`
- **Khive Principles**: "tools should unify, not multiply"
- **FastMCP Documentation**: To be researched
- **MCP Protocol**: JSON-RPC 2.0 over stdio

---

**Note**: This is a critical architectural refactor that blocks Session 002. Implementation must maintain full backward compatibility while dramatically simplifying the codebase through proper tool selection.