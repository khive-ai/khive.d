---
title: "Implementation Plan: Enhance khive mcp call with Pydapter-based Discovery and Validation"
id: "IP-148"
status: "draft"
date: "2025-05-24"
author: "@khive-implementer"
version: "0.1.0"
issue: "148"
depends_on: ["TDS-147", "TDS-149"]
search_keywords: ["mcp", "pydapter", "discovery", "validation", "adapter pattern", "cli enhancement"]
---

# Implementation Plan: Enhance khive mcp call with Pydapter-based Discovery and Validation

**Version:** 0.1.0
**Status:** Draft
**Author:** @khive-implementer
**Date:** 2025-05-24
**Related Issue:** [#148](https://github.com/khive-ai/khive.d/issues/148)
**Depends On:** TDS-147 (Pydapter Integration), TDS-149 (Security Architecture)

## 1. Implementation Overview

### 1.1. Goals
Transform the existing `khive mcp call` command from a static JSON-based interface to a dynamic, discoverable adapter system that demonstrates pydapter patterns in practice. This enhancement will:

- Implement `MCPServerAdapter` and `MCPDiscoveryAdapter` classes following TDS-147 patterns
- Add dynamic parameter discovery from MCP server schemas  
- Enhance CLI with natural argument parsing (eliminating JSON requirement)
- Integrate security capability checking points from TDS-149
- Maintain backward compatibility with existing usage

### 1.2. Key Components
1. **MCPServerAdapter**: Pydapter adapter for MCP server interactions
2. **MCPDiscoveryAdapter**: Adapter for discovering server capabilities and schemas
3. **Enhanced CLI Parser**: Natural language argument parsing with schema validation
4. **Security Integration Points**: Capability checking hooks for future security implementation
5. **Discovery Command**: New `khive mcp discover` command for listing servers and methods

## 2. Current State Analysis

### 2.1. Existing Implementation Strengths
- Robust MCP protocol implementation with proper JSON-RPC 2.0 support
- Connection management and server lifecycle handling
- Natural CLI argument parsing (--var, --json fallbacks)
- Comprehensive error handling and logging

### 2.2. Enhancement Opportunities
- Static configuration without runtime discovery of server capabilities
- No schema-driven validation of tool parameters
- Missing capability-based security integration points
- Limited discoverability of available tools and their schemas

## 3. Implementation Tasks

### 3.1. Phase 1: Pydapter Foundation (Priority: High)

#### Task 1.1: Create MCPServerAdapter Class
**File:** `src/khive/adapters/mcp_server_adapter.py`
**Dependencies:** TDS-147 patterns

```python
# Key implementation points:
# - Inherit from pydapter AsyncAdapter
# - Wrap existing MCPClient functionality  
# - Provide obj_key-based registry integration
# - Handle connection pooling and lifecycle
# - Support capability context integration (TDS-149)

class MCPServerAdapterConfig(BaseModel):
    server_name: str
    server_config: MCPServerConfig  # From existing implementation
    capability_context: Optional[CapabilityContext] = None  # TDS-149 integration

class MCPServerAdapter(AsyncAdapter[MCPToolRequest, MCPToolResponse]):
    def __init__(self, config: MCPServerAdapterConfig):
        self.config = config
        self._client: Optional[MCPClient] = None
    
    async def from_obj(self, data: MCPToolRequest, **kwargs) -> MCPToolResponse:
        # 1. Validate capability if provided (TDS-149 integration point)
        # 2. Get or create MCP client connection
        # 3. Execute tool call with parameter validation
        # 4. Return structured response
        pass
    
    @property
    def obj_key(self) -> str:
        return f"khive:mcp:server:{self.config.server_name}"
```

#### Task 1.2: Create MCPDiscoveryAdapter Class  
**File:** `src/khive/adapters/mcp_discovery_adapter.py`
**Dependencies:** TDS-147 patterns

```python
# Key implementation points:
# - Discover available servers and their tools
# - Extract and normalize tool schemas
# - Provide searchable tool metadata
# - Cache discovery results with TTL

class MCPDiscoveryAdapter(AsyncAdapter[MCPDiscoveryRequest, MCPDiscoveryResponse]):
    async def from_obj(self, data: MCPDiscoveryRequest, **kwargs) -> MCPDiscoveryResponse:
        # 1. Connect to all configured servers
        # 2. List available tools from each server
        # 3. Extract parameter schemas from tool definitions
        # 4. Return normalized discovery data
        pass
    
    @property
    def obj_key(self) -> str:
        return "khive:mcp:discovery"
```

#### Task 1.3: Define Data Models
**File:** `src/khive/adapters/mcp_models.py`

```python
# Pydantic models for MCP adapter interactions:

class MCPToolRequest(BaseModel):
    server_name: str
    tool_name: str
    arguments: Dict[str, Any]
    
class MCPToolResponse(BaseModel):
    success: bool
    result: Optional[Dict[str, Any]] = None
    error: Optional[str] = None
    
class MCPDiscoveryRequest(BaseModel):
    server_filter: Optional[str] = None
    tool_filter: Optional[str] = None
    
class MCPDiscoveryResponse(BaseModel):
    servers: List[MCPServerInfo]
    tools: List[MCPToolInfo]
    
class MCPServerInfo(BaseModel):
    name: str
    status: str
    tool_count: int
    capabilities: Dict[str, Any]
    
class MCPToolInfo(BaseModel):
    server_name: str
    tool_name: str
    description: Optional[str]
    parameters: Dict[str, Any]  # JSON Schema
    required_params: List[str]
```

### 3.2. Phase 2: CLI Enhancement (Priority: High)

#### Task 2.1: Implement Discovery Command
**File:** `src/khive/cli/khive_mcp.py` (enhance existing)

```python
# Add new 'discover' subcommand:
async def cmd_discover(config: MCPConfig, filters: Optional[Dict[str, str]] = None) -> Dict[str, Any]:
    """Discover available servers and tools with their schemas."""
    # Use MCPDiscoveryAdapter to get comprehensive server/tool info
    # Format results for human-readable output
    # Support filtering by server name or tool name patterns
    pass

# CLI parser addition:
discover_parser = subparsers.add_parser("discover", help="Discover servers and tools")
discover_parser.add_argument("--server", help="Filter by server name pattern")
discover_parser.add_argument("--tool", help="Filter by tool name pattern")
```

#### Task 2.2: Enhance Call Command with Schema Validation
**File:** `src/khive/cli/khive_mcp.py` (enhance existing)

```python
async def cmd_call_tool_enhanced(
    config: MCPConfig, 
    server_name: str, 
    tool_name: str, 
    arguments: Dict[str, Any]
) -> Dict[str, Any]:
    """Enhanced tool calling with schema validation and pydapter integration."""
    # 1. Use MCPDiscoveryAdapter to get tool schema
    # 2. Validate arguments against schema before calling
    # 3. Use MCPServerAdapter for the actual call
    # 4. Provide helpful error messages for validation failures
    pass

def parse_tool_arguments_with_schema(
    args: argparse.Namespace, 
    tool_schema: Dict[str, Any]
) -> Dict[str, Any]:
    """Enhanced argument parsing using tool schema for validation."""
    # 1. Parse CLI arguments as before
    # 2. Validate against JSON schema from tool definition
    # 3. Provide type coercion and validation errors
    # 4. Support auto-completion hints based on schema
    pass
```

### 3.3. Phase 3: Security Integration Points (Priority: Medium)

#### Task 3.1: Add Capability Context Support
**File:** `src/khive/adapters/mcp_server_adapter.py` (enhance)

```python
# Integration points for TDS-149 security:
class MCPServerAdapter(AsyncAdapter[MCPToolRequest, MCPToolResponse]):
    async def from_obj(self, data: MCPToolRequest, **kwargs) -> MCPToolResponse:
        # Security integration point:
        if self.config.capability_context:
            await self._validate_capability(data)
        
        # Existing tool call logic...
        pass
    
    async def _validate_capability(self, request: MCPToolRequest) -> None:
        """Placeholder for capability validation (TDS-149)."""
        # This will be implemented when the full security architecture is ready
        # For now, just log the capability check
        log_msg_mcp(f"Capability check: {self.config.capability_context.principal_id} -> {request.tool_name}")
        pass
```

#### Task 3.2: Add Audit Logging Hooks
**File:** `src/khive/adapters/mcp_server_adapter.py` (enhance)

```python
async def _audit_log_tool_call(
    self, 
    request: MCPToolRequest, 
    response: MCPToolResponse, 
    duration_ms: float
) -> None:
    """Audit logging hook for tool calls."""
    # Structured logging for security audit trail
    audit_data = {
        "timestamp": datetime.utcnow().isoformat(),
        "principal_id": self.config.capability_context.principal_id if self.config.capability_context else "unknown",
        "server_name": request.server_name,
        "tool_name": request.tool_name,
        "success": response.success,
        "duration_ms": duration_ms,
        "argument_count": len(request.arguments),
    }
    log_msg_mcp(f"AUDIT: {json.dumps(audit_data)}")
```

### 3.4. Phase 4: Registry Integration (Priority: Medium)

#### Task 4.1: Register Adapters in Pydapter Registry
**File:** `src/khive/adapters/__init__.py` (new)

```python
# Register MCP adapters in the global pydapter registry
from pydapter.registry import Registry
from .mcp_server_adapter import MCPServerAdapter, MCPServerAdapterConfig
from .mcp_discovery_adapter import MCPDiscoveryAdapter

async def register_mcp_adapters(config: MCPConfig) -> None:
    """Register MCP adapters in the pydapter registry."""
    registry = Registry()
    
    # Register discovery adapter
    registry.register(
        lambda: MCPDiscoveryAdapter(),
        obj_key="khive:mcp:discovery"
    )
    
    # Register server adapters for each configured server
    for server_name, server_config in config.servers.items():
        adapter_config = MCPServerAdapterConfig(
            server_name=server_name,
            server_config=server_config
        )
        registry.register(
            lambda cfg=adapter_config: MCPServerAdapter(cfg),
            obj_key=f"khive:mcp:server:{server_name}"
        )
```

## 4. Testing Strategy

### 4.1. Unit Tests
**Files:** `tests/adapters/test_mcp_*.py` (new)

- **MCPServerAdapter Tests:**
  - Connection management and lifecycle
  - Tool call parameter validation
  - Error handling and timeout scenarios
  - Capability context integration

- **MCPDiscoveryAdapter Tests:**
  - Server discovery and tool enumeration  
  - Schema extraction and normalization
  - Caching behavior and TTL expiration

### 4.2. Integration Tests
**Files:** `tests/cli/test_khive_mcp_enhanced.py` (new)

- **Discovery Command Tests:**
  - Full server discovery workflow
  - Filtering and search functionality
  - Human-readable output formatting

- **Enhanced Call Command Tests:**
  - Schema-validated tool calling
  - Argument parsing with type coercion
  - Error message clarity and helpfulness

### 4.3. Compatibility Tests
**Files:** `tests/cli/test_khive_mcp_compatibility.py` (new)

- Ensure existing MCP usage patterns continue to work
- Verify backward compatibility of argument parsing
- Test migration path from old to new patterns

## 5. Implementation Schedule

### Week 1: Foundation (Phase 1)
- **Days 1-2:** Create MCPServerAdapter and data models
- **Days 3-4:** Create MCPDiscoveryAdapter  
- **Day 5:** Unit tests for adapters

### Week 2: CLI Enhancement (Phase 2)
- **Days 1-2:** Implement discover command
- **Days 3-4:** Enhance call command with schema validation
- **Day 5:** Integration tests and CLI testing

### Week 3: Security & Registry (Phases 3-4)
- **Days 1-2:** Add security integration points
- **Days 3-4:** Registry integration and adapter factories
- **Day 5:** Comprehensive testing and documentation

## 6. Success Criteria

### 6.1. Functional Requirements
- [ ] `khive mcp discover` lists all servers and methods with schemas
- [ ] `khive mcp call` supports natural CLI syntax without JSON requirement  
- [ ] Parameter validation works automatically from server schemas
- [ ] Security capability checking integration points are implemented
- [ ] Backward compatibility with existing usage is maintained

### 6.2. Quality Requirements  
- [ ] Unit test coverage > 85% for new adapter classes
- [ ] Integration tests cover all new CLI commands
- [ ] Performance: Discovery command completes within 2 seconds
- [ ] Error messages are clear and actionable
- [ ] Documentation is comprehensive and includes examples

### 6.3. Architecture Requirements
- [ ] Follows TDS-147 pydapter patterns consistently
- [ ] Integrates TDS-149 security hooks appropriately  
- [ ] Uses proper obj_key naming conventions
- [ ] Maintains separation of concerns between adapters and CLI

## 7. Risk Mitigation

### 7.1. Technical Risks
- **Risk:** Pydapter integration complexity
  **Mitigation:** Start with simple adapter patterns, iterate based on TDS-147 examples

- **Risk:** Breaking existing MCP functionality  
  **Mitigation:** Comprehensive compatibility testing, feature flags for new behavior

- **Risk:** Performance overhead from discovery operations
  **Mitigation:** Implement caching, lazy loading, and async patterns

### 7.2. Timeline Risks
- **Risk:** Schema validation complexity exceeds estimates
  **Mitigation:** Implement basic validation first, enhance iteratively

- **Risk:** Security integration proves more complex than expected
  **Mitigation:** Use placeholder hooks initially, implement fully when TDS-149 is complete

## 8. Documentation Plan

### 8.1. Developer Documentation
- Update `docs/commands/khive_mcp.md` with new commands and examples
- Add `docs/adapters/mcp_adapters.md` explaining the pydapter integration
- Create migration guide for users of existing MCP functionality

### 8.2. API Documentation  
- Document all new data models and their schemas
- Provide examples of adapter usage patterns
- Include troubleshooting guide for common issues

### 8.3. Security Documentation
- Document capability integration points for future security implementation
- Explain audit logging format and usage
- Provide security best practices for MCP tool usage

## 9. Future Enhancements

### 9.1. Advanced Features (Post-Implementation)
- **Auto-completion:** CLI auto-completion based on discovered schemas
- **Interactive Mode:** Guided tool calling with parameter prompts
- **Batch Operations:** Execute multiple tool calls in sequence
- **Template System:** Save and reuse common tool call patterns

### 9.2. Security Enhancements (Dependent on TDS-149)
- **Full Capability Validation:** Complete implementation of capability checking
- **Policy Engine Integration:** Connect to centralized policy decision point
- **Audit Dashboard:** Web interface for viewing audit logs
- **Risk Scoring:** Automatic risk assessment for tool calls

This implementation plan provides a clear roadmap for enhancing the MCP CLI with pydapter patterns while maintaining backward compatibility and preparing for future security integration.