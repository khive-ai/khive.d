---
title: "Technical Design Specification - Session 002: Service Migration & Enhanced CLI"
id: TDS-002
status: "Draft"
date: "2025-05-24"
author: "@khive-architect"
version: "0.1.0"
related_issues: ["#135", "#136", "#137", "#138", "#139", "#140"]
depends_on: ["TDS-147", "TDS-149", "Session_001_foundation"]
---

## 1. Introduction

This document outlines the technical design for Session 002 of the Khive project. The primary goals of this session are to systematically migrate existing Khive services to the Pydapter adapter pattern, introduce new AI-enhanced CLI functionalities, and define robust composition patterns for orchestrating complex workflows. This session builds directly upon the Pydapter foundation established in Session 001 (`TDS-147.md`) and incorporates the security boundaries defined in `TDS-149.md`. Successful completion of Session 002 will significantly advance Khive towards becoming an intelligent tool orchestration platform.

## 2. Goals

-   Design a clear migration path for `InfoService`, `ReaderService`, `CommitService`, and `Build/CI` services to Pydapter-based adapters.
-   Specify the architecture for new CLI commands: `khive edit`, `khive plan`, and `khive test`, leveraging AI capabilities via FastMCP.
-   Define patterns for composing adapters into complex workflows, including error handling and security considerations.
-   Establish a service migration priority matrix.
-   Ensure all designs adhere to Khive's principles of CLI simplicity, tool unification, and high-quality, testable components (80%+ coverage).

## 3. Non-Goals

-   Full implementation of all migrated services and new CLI commands. This TDS focuses on the architectural design.
-   Detailed design of underlying LLM prompts for AI-assisted features (high-level interaction patterns will be defined).
-   Addressing issues from Session 001; this design assumes Session 001 deliverables are complete and correct, including the successful refactor to FastMCP.

## 4. Referenced Documents

-   `TDS-147.md`: Pydapter Foundation and Core Adapter Design.
-   `TDS-149.md`: Security Boundaries and Capability Management Framework.
-   Khive Research: "Adapter pattern mastery for AI development frameworks"
-   Khive Research: "Pydapter: Exhaustive Summary"
-   Khive Research: "Reflections on Khive's Security and Performance Research"

## 5. Proposed Architecture

The architecture for Session 002 revolves around three main pillars: Service Migration, Enhanced CLI Framework, and Composition Patterns. All components will be built using Pydapter models and adapters, ensuring consistency, type safety, and adherence to security protocols.

### 5.1. Service Migration Architecture

Existing Khive services will be refactored into Pydapter adapters. This promotes modularity, testability, and reusability, aligning with the Pydapter philosophy where services are compositions of adapters. Each adapter will encapsulate a specific domain of functionality.

**General Adapter Design Principles (referencing `TDS-147.md`):**

-   Each adapter will be a Pydapter `AsyncAdapter` or `Adapter`.
-   Interfaces will be defined using Pydantic models for request and response validation.
-   Adapters will use FastMCP for interactions with external tools or services, configured via `khive mcp`.
-   Security: Adapters will operate based on capability tokens passed to them, as per `TDS-149.md`.

**Specific Service Migrations:**

1.  **InfoService &rarr; `InfoAdapter`**:
    *   **Responsibilities**: Handling search queries (via `khive info search`) and LLM consultations (via `khive info consult`). (Evidence for provider choices/integration patterns: pplx:TODO)
    *   **Core Methods**:
        *   `async search(request: SearchRequestModel) -> SearchResponseModel`
        *   `async consult(request: ConsultRequestModel) -> ConsultResponseModel`
    *   **FastMCP Integration**: Will use FastMCP to connect to configured search providers (Perplexity, Exa) and LLM providers (OpenRouter).
    *   **Pydapter Features**: Leverages Pydapter for request/response validation and potentially for managing different provider configurations as sub-adapters or strategies.

2.  **ReaderService &rarr; `DocumentAdapter`**:
    *   **Responsibilities**: Opening, reading, and managing documents from various sources (local files, URLs).
    *   **Core Methods**:
        *   `async open(request: OpenRequestModel) -> OpenResponseModel` (returns `doc_id` and metadata)
        *   `async read_chunk(request: ReadChunkRequestModel) -> ReadChunkResponseModel`
        *   `async close(request: CloseRequestModel) -> CloseResponseModel`
    *   **FastMCP Integration**: May use FastMCP for fetching URL content if a generic HTTP tool is available and configured. Local file access will use Pydapter's file handling capabilities (potentially via a `FileSystemAdapter` if not core). (Evidence for large document handling/streaming: pplx:TODO)
    *   **Pydapter Features**: Manages document state (e.g., open documents, cursors) and uses Pydantic models for structured data exchange.

3.  **CommitService (and related Git operations) &rarr; `GitAdapter`**:
    *   **Responsibilities**: Handling Git operations like staging, committing (`khive commit`), branching, and potentially interacting with `gh` CLI functionalities for PRs (`khive pr`).
    *   **Core Methods**:
        *   `async stage_files(request: StageFilesRequestModel) -> StageFilesResponseModel`
        *   `async commit(request: CommitRequestModel) -> CommitResponseModel`
        *   `async create_branch(request: CreateBranchRequestModel) -> CreateBranchResponseModel`
        *   `async push_branch(request: PushBranchRequestModel) -> PushBranchResponseModel`
        *   `async create_pull_request(request: CreatePRRequestModel) -> CreatePRResponseModel` (leveraging `khive pr` logic)
    *   **FastMCP Integration**: Could use a `ShellToolAdapter` via FastMCP to execute `git` and `gh` commands, ensuring outputs are parsed and structured. This aligns with "CLI First, MCP Last" if direct library use is complex. (Evidence for robust shell interaction/parsing: pplx:TODO)
    *   **Pydapter Features**: Validates commit message formats, manages Git command parameters, and structures responses.

4.  **Build/CI Services (`khive ci`, `khive fmt`) &rarr; `BuildAdapter` / `FormatAdapter` / `TestRunnerAdapter`**:
    *   **Responsibilities**: Running formatters, linters, tests, and other CI-related tasks.
    *   **`FormatAdapter` Methods**: `async format(request: FormatRequestModel) -> FormatResponseModel`
    *   **`TestRunnerAdapter` Methods**: `async run_tests(request: TestRunRequestModel) -> TestRunResponseModel`
    *   **FastMCP Integration**: Similar to `GitAdapter`, these can use a `ShellToolAdapter` via FastMCP to execute underlying tools (`uv run`, `pytest`, `ruff`, `pre-commit`). (Evidence for best practices in CI tool integration: pplx:TODO)
    *   **Pydapter Features**: Manages configurations for different tools, parses output for success/failure and relevant metrics (e.g., test coverage).

**Migration Strategy:**

A phased approach is recommended:

1.  **Facade Implementation**: Initially, create Pydapter adapter interfaces that internally call the existing service logic. This allows dependent components to start using the new adapter interface immediately.
2.  **Incremental Refactor**: Gradually refactor the internal logic of the legacy services into the new adapter structure, replacing direct calls with FastMCP-brokered calls where appropriate.
3.  **Deprecation**: Once an adapter is fully migrated and tested, the old service can be deprecated and eventually removed.

### 5.2. Enhanced CLI Framework

New CLI commands will be introduced to enhance developer productivity, leveraging AI and the newly defined adapters.

1.  **`khive edit --file <path> --instructions "<prompt>"`**:
    *   **Purpose**: AI-assisted code editing. Allows users to specify a file and natural language instructions for changes.
    *   **Functionality**:
        1.  Reads the content of `<path>` (using `DocumentAdapter` or a core file reader).
        2.  Sends the content and `<prompt>` to an LLM via `InfoAdapter.consult()` (or a dedicated `LLMAdapter`).
        3.  The LLM returns a diff or the modified code.
        4.  Presents the diff to the user for confirmation (interactive).
        5.  Applies the changes if confirmed (using a file writing utility, possibly part of `DocumentAdapter` or a core Pydapter capability). (Evidence for AI code editing patterns/safety: pplx:TODO)
    *   **Adapters Used**: `DocumentAdapter`, `InfoAdapter` (or `LLMAdapter`).
    *   **FastMCP**: LLM interaction via FastMCP.

2.  **`khive plan --task "<description>" [--context <files_or_urls>]`**:
    *   **Purpose**: AI-assisted project planning and issue generation.
    *   **Functionality**:
        1.  User provides a task description and optional context (files/URLs).
        2.  Context is read using `DocumentAdapter`.
        3.  Task description and context are sent to an LLM via `InfoAdapter.consult()` to generate a plan (e.g., steps, sub-tasks, potential issues).
        4.  Presents the plan to the user.
        5.  Optionally, generates GitHub issues for plan items (using `GitAdapter` or a `GitHubAdapter` which would use FastMCP to interact with the GitHub API). (Evidence for LLM-based planning and issue generation: pplx:TODO)
    *   **Adapters Used**: `DocumentAdapter`, `InfoAdapter`, `GitAdapter` (or `GitHubAdapter`).
    *   **FastMCP**: LLM interaction, GitHub API interaction.

3.  **`khive test [--file <path>] [--auto-generate]`**:
    *   **Purpose**: Intelligent test generation and execution.
    *   **Functionality**:
        1.  If `--auto-generate` and `<file>` are provided, reads the file (using `DocumentAdapter`) and sends its content to an LLM via `InfoAdapter.consult()` to suggest test cases or generate boilerplate test code.
        2.  Saves generated tests (user confirmation).
        3.  Executes tests (for the specified file or entire project) using `TestRunnerAdapter`.
        4.  Reports results, including coverage. (Evidence for AI-driven test generation techniques: pplx:TODO)
    *   **Adapters Used**: `DocumentAdapter`, `InfoAdapter`, `TestRunnerAdapter`.
    *   **FastMCP**: LLM interaction for test generation.

### 5.3. Composition Patterns

Complex workflows in Khive will be achieved by composing adapters. This leverages Pydapter's design for creating services as adapter compositions.

1.  **Pipeline Composition**:
    *   **Mechanism**: Adapters will be chained sequentially, where the output of one adapter (potentially transformed) becomes the input for the next.
    *   **Orchestration**: A lightweight workflow orchestrator within Khive CLI commands or dedicated workflow functions will manage the chain. This could be implemented using Pydapter's `BaseModel` to define workflow state and pass it through adapters.
    *   **Example Workflow (`khive magic-feature "<desc>"` - hypothetical)**:
        1.  `khive plan --task "<desc>"` &rarr; `PlanningAdapter` (uses `InfoAdapter`, `GitHubAdapter`) &rarr; Plan Output (e.g., list of files to create/modify).
        2.  For each planned change: `khive edit --file <file> --instructions "<change_desc>"` &rarr; `EditingAdapter` (uses `DocumentAdapter`, `InfoAdapter`) &rarr; Code Diff.
        3.  `khive test --auto-generate --file <changed_file>` &rarr; `TestingAdapter` (uses `DocumentAdapter`, `InfoAdapter`, `TestRunnerAdapter`) &rarr; Test Results.
        4.  `khive commit --type feat --subject "Implement magic feature"` &rarr; `GitAdapter` &rarr; Commit Result. (Evidence for robust workflow orchestration patterns: pplx:TODO)

2.  **Error Handling and Rollback**:
    *   **Adapter-Level**: Each adapter should implement idempotent operations where possible and handle its own transient errors (e.g., retries for network calls via FastMCP).
    *   **Workflow-Level**:
        *   The orchestrator will catch exceptions from adapters.
        *   For critical errors, a compensation strategy might be needed (e.g., if issue creation fails after code generation, log the failure but don't automatically revert code).
        *   Pydapter's event system (`@as_event`) can be used for detailed logging and auditing of workflow steps and errors.
    *   **Circuit Breakers**: Consider for adapters calling external services that might be unreliable.

3.  **Adapter Chaining and Security (`TDS-149.md`)**:
    *   **Capability Tokens**: When an adapter calls another, it must pass a capability token that is a subset of its own capabilities, or a new token derived according to the rules in `TDS-149.md`.
    *   **Validation**: Each adapter, upon receiving a request, must validate the incoming capability token to ensure the caller is authorized for the requested operation.
    *   **FastMCP Security**: When adapters use FastMCP, the `khive mcp` layer is responsible for enforcing that the adapter only calls allowed tools on the MCP server, based on its own capabilities. The FastMCP call itself might also involve its own token/auth mechanism to the external tool, managed by `khive mcp`'s configuration.

## 6. Service Migration Priority Matrix

| Service          | Proposed Adapter(s)                     | Priority | Justification                                                                                                | Dependencies                               |
| ---------------- | --------------------------------------- | -------- | ------------------------------------------------------------------------------------------------------------ | ------------------------------------------ |
| InfoService      | `InfoAdapter`                           | 1 (High) | Fundamental for new AI CLI features (`edit`, `plan`, `test`). Core to Khive's intelligence.                  | Pydapter, FastMCP, `TDS-149`               |
| ReaderService    | `DocumentAdapter`                       | 1 (High) | Essential for `khive edit`, `khive plan`, `khive test` to read files and context.                            | Pydapter, FastMCP (for URLs)               |
| CommitService    | `GitAdapter`                            | 2 (Medium) | Core for `khive commit`, `khive pr`, and potentially used by `khive plan` for issue tracking.                 | Pydapter, FastMCP (for `git`/`gh` via shell) |
| Build/CI Services | `BuildAdapter`, `FormatAdapter`, `TestRunnerAdapter` | 2 (Medium) | `TestRunnerAdapter` is key for `khive test`. `FormatAdapter` supports `khive fmt`. `BuildAdapter` for `khive ci`. | Pydapter, FastMCP (for tools via shell)    |

## 7. Testing Strategy

-   All new adapters and CLI commands must achieve **80%+ unit test coverage**.
-   Integration tests will be crucial for verifying adapter compositions and interactions with FastMCP tools.
-   The `khive test --auto-generate` feature will be dogfooded to help generate tests for Khive itself.
-   Pydapter's validation capabilities will be heavily relied upon for ensuring data integrity at adapter boundaries.

## 8. Risks and Mitigations

1.  **Increased Complexity with AI Integration**:
    *   **Risk**: AI-assisted features can be non-deterministic and hard to test thoroughly. CLI interactions might become complex.
    *   **Mitigation**: Start with well-defined, narrow AI tasks. Provide clear feedback to users. Implement robust parsing and validation of LLM outputs. Focus on augmenting developer workflows, not fully automating them initially. (Evidence: General software engineering principles for AI).
2.  **Performance of Chained Adapters/FastMCP Calls**:
    *   **Risk**: Multiple sequential adapter calls, especially those involving LLMs via FastMCP, could lead to noticeable latency in CLI commands.
    *   **Mitigation**: Design for asynchronous operations where feasible. Utilize Pydapter's performance features. Implement caching for LLM responses where appropriate (e.g., semantic caching if context is identical, `TDS-147.md` might discuss Pydapter caching). Profile and optimize critical paths. (Evidence: Khive research on performance).
3.  **Security of AI-Generated Code/Plans**:
    *   **Risk**: `khive edit` and `khive plan` might suggest insecure code or actions if the LLM is not properly guided or its output isn't validated.
    *   **Mitigation**: Always require user confirmation for applying AI-generated changes. Implement safety filters on LLM prompts and outputs. Educate users about reviewing AI suggestions. Integrate with static analysis tools if possible before applying changes. (Evidence: `TDS-149.md` principles).
4.  **Scope Creep for New CLI Tools**:
    *   **Risk**: The new CLI tools (`edit`, `plan`, `test`) have broad potential, which could lead to scope creep during implementation.
    *   **Mitigation**: Define clear MVPs (Minimum Viable Products) for each tool in Session 002. Defer advanced features to subsequent sessions. Focus on core functionality and user experience.

## 9. Open Questions

1.  What is the detailed structure and capability set of the `LLMAdapter`? Is it a specialized version of `InfoAdapter` or a distinct entity?
2.  How will Pydapter's event system be specifically utilized for tracing and debugging composed workflows?
3.  What are the specific Pydantic models for requests/responses for each new adapter and CLI interaction? (To be detailed during implementation planning).
4.  Will `khive plan` directly create GitHub issues, or will it output a plan that the user then manually converts or uses another tool for? (Initial design suggests optional direct creation).

## 10. Future Considerations

-   A more sophisticated visual workflow designer/monitor for complex adapter compositions.
-   Self-healing workflows where the system can retry or choose alternative adapters upon failure.
-   Personalized AI assistance in CLI tools based on user history and project context.
-   Expanding adapter types to cover more external services and tools.