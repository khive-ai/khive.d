---
title: "Technical Design Specification: Pydapter Integration for Khive Services"
id: "TDS-147"
status: "draft"
date: "2025-05-24"
author: "@khive-architect"
version: "0.1.0"
issue: "147"
search_keywords: ["pydapter", "khive", "service architecture", "adapter pattern", "microservices"]
---

# Technical Design Specification: Pydapter Integration for Khive Services

**Version:** 0.1.0
**Status:** Draft
**Author:** @khive-architect
**Date:** 2025-05-24
**Related Issue:** [#147](https://github.com/khive-ai/khive.d/issues/147)

## 1. Introduction and Goals

### 1.1. Overview
This document outlines the technical design for integrating the Pydapter library into Khive services. The primary goal is to transform existing monolithic service implementations into a composable, adapter-based architecture. This change is foundational for Khive's "agents by agents" vision, enabling more flexible, maintainable, and scalable service development.

### 1.2. Goals
- Define a clear architectural pattern for services as orchestrators of Pydapter adapters.
- Specify the structure and mechanisms for an adapter registry enabling dynamic discovery and composition.
- Design a bridge architecture to connect or transform existing `EndpointConfig` patterns to the new Pydapter adapter model.
- Outline a phased migration strategy for existing Khive services (e.g., `InfoService`, `ReaderService`) to the new architecture, ensuring backward compatibility where necessary.
- Ensure the design supports both current Khive functionalities and future requirements for dynamic agent interaction.

### 1.3. Non-Goals
- Full implementation details of every adapter for every service.
- Complete rewrite of all existing services in the first phase.
- Detailed design of the "agents by agents" interaction protocol beyond foundational Pydapter integration.

### 1.4. Glossary
- **Pydapter:** The Python library providing composable data models and an adapter pattern.
- **Adapter:** A Pydapter component responsible for a specific unit of work, such as interacting with an external API, transforming data, or executing a specific logic.
- **Service-as-Orchestrator:** An architectural pattern where Khive services (e.g., `InfoService`) primarily coordinate and delegate tasks to Pydapter adapters rather than implementing the logic directly.
- **Adapter Registry:** A central mechanism for registering, discovering, and retrieving Pydapter adapters.
- **`EndpointConfig`:** The current Khive class used to define connection and request parameters for external APIs.
- **`obj_key`:** A Pydapter concept, a string key used to identify and look up specific adapters or configurations in the registry.

## 2. Current Architecture and Challenges

### 2.1. Overview of Existing Service Implementation (e.g., `InfoService`)
- Services like `InfoService` directly manage HTTP client instances or SDKs.
- Logic for specific providers (e.g., Perplexity, Exa, OpenRouter) is embedded within service methods.
- Configuration is managed via `EndpointConfig` objects, often resolved at runtime using `match_endpoint`.
- Limited composability and reusability of specific API interaction logic.
- Challenges in testing individual provider interactions in isolation.

### 2.2. Limitations of Current Approach
- **Monolithic Structure:** Service logic is tightly coupled, making changes and extensions complex.
- **Boilerplate:** Similar patterns for API calls, error handling, and request/response processing are repeated across services and providers.
- **Testability:** Difficult to mock or isolate specific external dependencies for unit testing.
- **Scalability:** Adding new providers or functionalities often requires significant modifications to existing service code.
- **Flexibility:** Less adaptable to dynamic composition required by the "agents by agents" vision.

## 3. Proposed Pydapter-Based Architecture

### 3.1. Core Principles
- **Services as Orchestrators:** Khive services will become lightweight orchestrators that leverage Pydapter's `AsyncAdaptable` mixin to delegate operations to specialized adapters.
- **Granular Adapters:** Adapters will encapsulate specific functionalities, such as calling a particular API endpoint, transforming data, or performing a defined computation.
- **Configuration-Driven Adapters:** Adapters will be configurable, potentially using a transformed version of the existing `EndpointConfig` or a new Pydapter-native configuration model.
- **Centralized Adapter Registry:** A registry will manage adapter instances or configurations, allowing for dynamic lookup and composition.

### 3.2. Service-as-Orchestrator Pattern Transformation
This section will detail how a service like `InfoService` transforms.

#### 3.2.1. Current `InfoService` Structure (Simplified)
```python
# class InfoService:
#     def __init__(self):
#         self._perplexity_endpoint = match_endpoint("perplexity", "chat")
#         # ... other endpoints
#
#     async def _perplexity_search(self, params):
#         # direct call using self._perplexity_endpoint.call(...)
#         pass
#
#     async def handle_request(self, request: InfoRequest):
#         if request.action == InfoAction.SEARCH and request.params.provider == SearchProvider.PERPLEXITY:
#             return await self._perplexity_search(...)
```

#### 3.2.2. Transformed `InfoService` with Pydapter
```python
# from pydapter.interfaces import AsyncAdaptable
# from pydantic import BaseModel
#
# class InfoService(BaseModel, AsyncAdaptable): # Implements Pydapter's AsyncAdaptable
#     async def handle_request(self, request: InfoRequest) -> InfoResponse:
#         if request.action == InfoAction.SEARCH:
#             adapter_key = f"khive:info:search:{request.params.provider.value.lower()}"
#             # Pydapter handles dispatch to the correct adapter via obj_key
#             # The adapter itself will be configured with necessary details (URL, auth, etc.)
#             # The `request.params.provider_params` becomes the input to the adapter.
#             adapted_response = await self.adapt_from_async(
#                 request.params.provider_params,
#                 obj_key=adapter_key
#             )
#             # adapted_response is expected to be the raw response from the provider
#             # Map it back to InfoResponse
#             return InfoResponse(success=True, action_performed=InfoAction.SEARCH, content=adapted_response)
#
#         elif request.action == InfoAction.CONSULT:
#             # Similar pattern for consult, potentially one adapter per model or a generic OpenRouter adapter
#             # For multiple models, the service might orchestrate multiple adapt_from_async calls
#             # or a specialized "multi_consult_adapter" could handle it.
#             # Example:
#             consult_adapter_key = "khive:info:consult:openrouter"
#             # Input to adapter would be InfoConsultParams
#             raw_consult_results = await self.adapt_from_async(
#                 request.params, # Assuming InfoConsultParams is the input type for the adapter
#                 obj_key=consult_adapter_key
#             )
#             return InfoResponse(success=True, action_performed=InfoAction.CONSULT, content=raw_consult_results)
#
#         return InfoResponse(success=False, error="Invalid action or parameters.")
#
#     async def close(self) -> None:
#         # Pydapter adapters might have their own lifecycle management,
#         # or the registry could handle closing resources.
#         # If InfoService holds direct references to closeable resources (less likely with pydapter), close them here.
#         # For now, assume Pydapter or the registry handles adapter resource cleanup.
#         pass
```
**Rationale:**
- `InfoService` no longer contains direct HTTP call logic or provider-specific handling.
- It uses `self.adapt_from_async()` with a dynamically constructed `obj_key` to delegate to the appropriate Pydapter adapter.
- The input to `adapt_from_async` is the specific parameters for that operation (e.g., `provider_params` for search, `InfoConsultParams` for consult).
- The adapter is responsible for the actual interaction with the external service.
- The service is responsible for mapping the raw adapter output back to the `InfoResponse` format if necessary (though adapters could also return a Pydantic model that's directly usable).

### 3.3. Pydapter Adapter Design

#### 3.3.1. General Adapter Structure
We will define a base Khive Pydapter adapter or rely on Pydapter's built-in adapter protocols.
A common pattern will be an `HttpApiAdapter` that can be configured to call any RESTful API. This adapter will use an underlying asynchronous HTTP client library like `httpx` (as shown in the example) or `aiohttp`. Its configuration will be managed by a Pydantic model, and it will incorporate robust error handling for API responses and connection issues. (pplx:97ce7e25-2a6a-4fba-b3c8-7b2e7f3d1d9d)

```python
# from pydapter.adapters import AsyncAdapter
# from pydantic import BaseModel, HttpUrl, Field
# import httpx # Or aiohttp
# from typing import Any, Literal, Optional
#
# class HttpApiAdapterAuthConfig(BaseModel):
#     # Example: could be expanded for different auth types like OAuth, API Key in header/query, etc.
#     token: Optional[str] = None
#     auth_type: Literal["bearer", "api_key"] = "bearer" # Example
#     api_key_name: Optional[str] = None # For api_key in header/query
#
# class HttpApiAdapterConfig(BaseModel):
#     base_url: HttpUrl
#     endpoint: str # e.g., "/v1/search"
#     method: Literal["GET", "POST", "PUT", "DELETE"] = "POST"
#     headers: dict[str, str] = Field(default_factory=dict)
#     auth: Optional[HttpApiAdapterAuthConfig] = None
#     # Potentially: request_schema_model (Pydantic model for request validation)
#     # Potentially: response_schema_model (Pydantic model for response parsing/validation)
#     timeout_seconds: int = 30
#
# class HttpApiAdapter(AsyncAdapter[Any, Any]): # Input Pydantic model or dict, Output Pydantic model or dict
#     def __init__(self, config: HttpApiAdapterConfig):
#         self.config = config
#         self._client: Optional[httpx.AsyncClient] = None
#
#     async def _get_client(self) -> httpx.AsyncClient:
#         if self._client is None or self._client.is_closed:
#             # Prepare headers, including authentication
#             final_headers = self.config.headers.copy()
#             if self.config.auth and self.config.auth.token:
#                 if self.config.auth.auth_type == "bearer":
#                     final_headers["Authorization"] = f"Bearer {self.config.auth.token}"
#                 elif self.config.auth.auth_type == "api_key" and self.config.auth.api_key_name:
#                     final_headers[self.config.auth.api_key_name] = self.config.auth.token
#
#             self._client = httpx.AsyncClient(
#                 base_url=str(self.config.base_url),
#                 headers=final_headers,
#                 timeout=self.config.timeout_seconds
#             )
#         return self._client
#
#     async def from_obj(self, data: Any, **kwargs) -> Any:
#         """
#         'data' here is the payload for the HTTP request, typically a Pydantic model or dict.
#         The adapter uses its config to make the actual HTTP call.
#         """
#         client = await self._get_client()
#         # If data is a Pydantic model, convert to dict for JSON payload
#         payload_json = data.model_dump(exclude_none=True) if isinstance(data, BaseModel) else data
#         payload_params = data.model_dump(exclude_none=True) if isinstance(data, BaseModel) else data
#
#         try:
#             response = await client.request(
#                 method=self.config.method,
#                 url=self.config.endpoint, # Assumes endpoint is relative
#                 json=payload_json if self.config.method in ["POST", "PUT"] else None,
#                 params=payload_params if self.config.method == "GET" else None
#             )
#             response.raise_for_status() # Raise an httpx.HTTPStatusError for 4xx/5xx responses
#             # Consider response schema validation here if response_schema_model is defined
#             return response.json()
#
#         except httpx.HTTPStatusError as e:
#             # Log the error, potentially transform into a standardized error response
#             # (pplx:97ce7e25-2a6a-4fba-b3c8-7b2e7f3d1d9d - emphasizes error handling)
#             error_content = {"detail": f"API call failed: {e.response.status_code}", "response_text": e.response.text}
#             # Depending on desired behavior, could raise a custom exception or return a structured error
#             raise RuntimeError(f"API Error: {e.response.status_code} - {e.request.url} - {e.response.text}") from e
#         except httpx.RequestError as e: # Handles connection errors, timeouts, etc.
#             # (pplx:97ce7e25-2a6a-4fba-b3c8-7b2e7f3d1d9d - emphasizes error handling)
#             raise RuntimeError(f"Request Error: {e.request.url} - {str(e)}") from e
#         except Exception as e: # Catch-all for other unexpected errors
#             raise RuntimeError(f"HttpApiAdapter unexpected error: {str(e)}") from e
#
#     async def to_obj(self, data: Any, **kwargs) -> Any:
#         # Typically not used if the adapter's primary role is to fetch/send data via from_obj
#         raise NotImplementedError("to_obj is not implemented for this HttpApiAdapter")
#
#     async def aclose(self):
#         if self._client and not self._client.is_closed:
#             await self._client.aclose()
```

#### 3.3.2. Specific Adapters for `InfoService`
- **`PerplexitySearchAdapter`**: An instance or specialization of `HttpApiAdapter` configured with Perplexity's API details.
  - `obj_key`: `"khive:info:search:perplexity"`
  - Input: `PerplexityChatRequest` (or a dict that can be validated into it).
  - Output: Raw JSON response from Perplexity.
- **`ExaSearchAdapter`**: An instance or specialization of `HttpApiAdapter` configured with Exa's API details.
  - `obj_key`: `"khive:info:search:exa"`
  - Input: `ExaSearchRequest` (or a dict).
  - Output: Raw JSON response from Exa.
- **`OpenRouterConsultAdapter`**: An instance or specialization of `HttpApiAdapter` configured for OpenRouter.
  - `obj_key`: `"khive:info:consult:openrouter"`
  - Input: `InfoConsultParams` (the adapter will internally construct the payload for OpenRouter, potentially handling multiple model calls if not done by the service).
  - Output: Dictionary of results from OpenRouter.

### 3.4. Adapter Registry and Discovery

#### 3.4.1. Registry Structure
A central registry (e.g., a singleton or a globally accessible object) will store adapter configurations or factory functions. Pydapter's default registry mechanism or a custom Khive extension can be used. This registry will internally use a Python dictionary for efficient O(1) lookups based on the `obj_key`. (pplx:5290785a-10a3-4180-9647-ea77be185440)

```python
# Example conceptual registry
# from pydapter.registry import Registry
# from typing import Callable, Awaitable, Any
#
# # Define a type for adapter factories for clarity
# AdapterFactory = Callable[[], Awaitable[Any]] # Assuming adapters are async
#
# khive_adapter_registry = Registry() # Pydapter's registry or a Khive wrapper
#
async def perplexity_search_adapter_factory() -> HttpApiAdapter: # Type hint for clarity
#     # Load EndpointConfig for perplexity
#     # This logic would fetch and transform EndpointConfig
#     ep_config_data = await get_endpoint_config_data_async("perplexity", "chat") # Placeholder for async config loading
#     # Map EndpointConfig fields to HttpApiAdapterConfig
#     # Example:
#     # adapter_config_dict = {
#     #    "base_url": ep_config_data.get("base_url"),
#     #    "endpoint": ep_config_data.get("endpoint"),
#     #    "method": ep_config_data.get("method", "POST"),
#     #    "headers": resolve_headers(ep_config_data), # Placeholder for header resolution logic
#     # }
#     # adapter_config = HttpApiAdapterConfig(**adapter_config_dict)
#     # return HttpApiAdapter(config=adapter_config)
    pass # Placeholder for actual factory implementation
#
# # Explicit registration, likely at application startup
khive_adapter_registry.register(
    perplexity_search_adapter_factory, # Registering the factory
    obj_key="khive:info:search:perplexity"
)
#
# # Similarly for Exa and OpenRouter
# # ...
```
- The registry will map `obj_key` strings to adapter factories. (pplx:5290785a-10a3-4180-9647-ea77be185440)
- Adapter factories are preferred for several reasons:
    - **Lazy Initialization**: Adapters, especially I/O-bound ones, are created only when first needed, conserving resources. (pplx:0756471f-4a4b-4f9f-b1eb-cf43f25895cb)
    - **Complex Configuration Management**: Factories encapsulate the logic for loading, transforming (e.g., from `EndpointConfig`), and validating adapter-specific configurations. This keeps the registry clean and centralizes complex setup. (pplx:0756471f-4a4b-4f9f-b1eb-cf43f25895cb)
    - **Dependency Management**: Factories can manage dependencies required by adapters, such as shared HTTP clients or connection pools.
    - **Decoupling and Flexibility**: Promotes loose coupling between the client code (service) and concrete adapter implementations, making the system easier to extend. (pplx:0756471f-4a4b-4f9f-b1eb-cf43f25895cb)
- Registration of these factories should be explicit, typically occurring during application startup to ensure all necessary adapters are known to the system. (pplx:5290785a-10a3-4180-9647-ea77be185440)

#### 3.4.2. Dynamic Discovery and Usage
- `obj_keys` will follow a consistent naming convention: `khive:<service_name>:<action>[:<provider_or_target>]`. This structured key approach aids maintainability. (pplx:5290785a-10a3-4180-9647-ea77be185440)
- Services construct these keys dynamically based on request parameters.
- Pydapter's `AsyncAdaptable.adapt_from_async` will use this key to look up the adapter in the registered `khive_adapter_registry`.

### 3.5. EndpointConfig to Adapter Bridge

#### 3.5.1. Mapping `EndpointConfig` to `HttpApiAdapterConfig`
The existing `EndpointConfig` holds most of the information needed for the `HttpApiAdapterConfig`. A mapping function or logic within adapter factories will perform this transformation.

- `EndpointConfig.base_url` -> `HttpApiAdapterConfig.base_url`
- `EndpointConfig.endpoint` -> `HttpApiAdapterConfig.endpoint`
- `EndpointConfig.method` -> `HttpApiAdapterConfig.method`
- `EndpointConfig.default_headers` (plus auth headers derived from `auth_type` and `api_key`) -> `HttpApiAdapterConfig.headers`
- `EndpointConfig.request_options` (schema) could be used by the adapter for payload validation if not handled by Pydantic models passed in.

#### 3.5.2. Loading Mechanism
The adapter factories in the registry will be responsible for:
1. Retrieving the relevant `EndpointConfig` (e.g., using a refined `match_endpoint` or a new configuration service).
2. Transforming `EndpointConfig` fields into the adapter's specific configuration model (e.g., `HttpApiAdapterConfig`).
3. Instantiating and returning the adapter.

This keeps the service layer clean of `EndpointConfig` details.

## 4. Migration Strategy

### 4.1. Phase 1: Foundational Pydapter Setup & InfoService Transformation
- **Goal:** Implement the core Pydapter registry, the generic `HttpApiAdapter`, and refactor `InfoService` to use this new pattern.
- **Steps:**
    1. Integrate Pydapter library into Khive.
    2. Implement `HttpApiAdapter` and `HttpApiAdapterConfig`.
    3. Implement the `khive_adapter_registry` and registration mechanism for adapters.
    4. Create adapter factories for Perplexity search, Exa search, and OpenRouter consult, using existing `EndpointConfig` data for their configuration.
    5. Refactor `InfoService` to derive from `BaseModel, AsyncAdaptable` and use `adapt_from_async` with the new adapters.
    6. Ensure all existing tests for `InfoService` pass after refactoring. This implies that the external behavior of `InfoService` remains unchanged.
- **Backward Compatibility:** `InfoService`'s public API (`handle_request`) remains the same. The change is internal.

### 4.2. Phase 2: Refactor Other Services (e.g., ReaderService)
- **Goal:** Apply the established Pydapter pattern to other Khive services.
- **Steps:**
    1. Identify adapters needed for `ReaderService` and other services.
    2. Implement and register these adapters.
    3. Refactor the services.
    4. Update tests.

### 4.3. Phase 3: Advanced Pydapter Features & Optimizations
- **Goal:** Explore and implement more advanced Pydapter features.
- **Steps:**
    1. Utilize Pydapter's field system for more robust data contracts within adapters if beneficial.
    2. Explore Pydapter's event system for logging/tracing adapter calls.
    3. Investigate opportunities for adapter composition and more complex Pydapter patterns.
    4. Refine adapter configuration and management.

### 4.4. Tooling and Developer Experience
- Develop helper functions or CLI commands for creating and registering new adapters.
- Ensure clear documentation for the new adapter-based architecture.

## 5. Data Models and Interfaces
- `InfoRequest`, `InfoResponse`, `InfoConsultParams` (from `src/khive/services/info/parts.py`) remain largely the same for the service's external contract.
- Adapters will have their own input/output Pydantic models, or accept/return raw data (e.g., dicts, JSON strings) that the service layer then maps. For HTTP adapters, input is typically a Pydantic model representing the request body/params, and output is the parsed JSON response.
- `HttpApiAdapterConfig` as defined above.

## 6. Security Considerations
- API keys and sensitive credentials, currently handled by `EndpointConfig` and `khive.config.settings.get_secret`, will need to be securely passed to or accessed by the adapter configurations. The `HttpApiAdapterConfig` should handle sensitive fields appropriately (e.g., using `SecretStr`).
- Pydapter's capability-based security model is not explicitly leveraged in this initial integration phase but should be kept in mind for future enhancements, especially for the "agents by agents" vision. For now, trust is managed at the service/configuration level.

## 7. Testing Strategy
- **Unit Tests:**
    - Services (e.g., `InfoService`) will be tested by mocking `self.adapt_from_async` to ensure correct `obj_key` and parameters are passed.
    - Individual adapters (e.g., `HttpApiAdapter`) will be unit-tested by mocking the underlying HTTP client (`httpx.AsyncClient`) to verify correct request formation and response handling.
- **Integration Tests:**
    - Test the `InfoService` with real (or mock-server-backed) adapters to ensure end-to-end functionality.
    - Test adapter registration and discovery.
- Existing integration tests for services should continue to pass, verifying that the refactoring maintains external behavior.

## 8. Risks and Mitigations

| Risk                                       | Likelihood | Impact | Mitigation                                                                                                                               |
|--------------------------------------------|------------|--------|------------------------------------------------------------------------------------------------------------------------------------------|
| Complexity in mapping `EndpointConfig`     | Medium     | Medium | Develop a clear mapping strategy and utility functions. Start with a few key examples.                                                     |
| Performance overhead from Pydapter layer   | Low        | Medium | Pydapter is designed for performance. Benchmark critical paths. Initial focus is on architecture, optimize later if needed.                  |
| Difficulty in debugging adapter chains     | Medium     | Medium | Implement good logging within adapters and the Pydapter invocation path. Pydapter's event system might help in later phases.                 |
| Learning curve for Pydapter for the team   | Medium     | Low    | Provide internal workshops, documentation, and pair programming for the first few adapter implementations.                                 |
| Backward compatibility issues              | Low        | High   | Maintain public service interfaces. Test thoroughly. Phased rollout.                                                                       |

## 9. Open Questions and Future Considerations
- How will Pydapter's more advanced features (field system, semantic validation, event system) be leveraged in Khive beyond basic adapter invocation? (Phase 3)
- Detailed error handling and propagation strategy from adapters back to the service and then to the client.
- Lifecycle management of adapters (e.g., closing connections) – will Pydapter's registry handle this, or will adapters need explicit `aclose` methods called by the service or a central manager? (The example `HttpApiAdapter` includes `aclose`).
- How to best manage shared resources (like `httpx.AsyncClient` instances) across multiple adapter instances if they target the same base URL but different endpoints? (Factories can manage shared clients).

## 10. Deployment Considerations
- This change is primarily architectural and internal to the service implementations.
- Existing deployment scripts should not require major changes initially, as the external service contracts are maintained.
- Ensure Pydapter is added as a core dependency.

## 11. Documentation Plan
- Update Khive developer documentation to reflect the new adapter-based service architecture.
- Provide examples of how to create and register new adapters.
- Document the `obj_key` naming convention.

This TDS provides the initial design. Further details will be refined during implementation.