---
title: "Technical Design Specification: IsolatedAdapter Security Architecture"
id: "TDS-149"
status: "draft"
date: "2025-05-24"
author: "@khive-architect"
version: "0.1.0"
issue: "149"
depends_on: "TDS-147"
search_keywords: ["pydapter", "khive", "security", "IsolatedAdapter", "CBAC", "agent security", "trust zones"]
---

# Technical Design Specification: IsolatedAdapter Security Architecture

**Version:** 0.1.0
**Status:** Draft
**Author:** @khive-architect
**Date:** 2025-05-24
**Related Issue:** [#149](https://github.com/khive-ai/khive.d/issues/149)
**Depends On:** [TDS-147](./TDS-147.md) Pydapter Integration

## 1. Introduction and Goals

### 1.1. Overview
This document details the technical design for the `IsolatedAdapter` security architecture within the Khive ecosystem. Building upon the Pydapter integration ([`TDS-147.md`](./TDS-147.md)), this specification introduces robust security boundaries, enabling Khive's "for agents, by agents" vision where untrusted or semi-trusted components can interact safely and securely. The core of this architecture is a Capability-Based Access Control (CBAC) system, complemented by agent-aware security policies, trust zones, and comprehensive auditing.

### 1.2. Goals
- Define the `IsolatedAdapter` concept and its role in enforcing security boundaries.
- Specify a comprehensive Capability-Based Access Control (CBAC) system, including capability token definition, issuance, and validation.
- Design agent-aware security policies and the concept of trust zones to manage interactions between different agents and services.
- Detail mechanisms for runtime security validation with minimal performance impact.
- Specify the format, storage, and management strategy for audit trails.
- Outline the integration of `IsolatedAdapter` and capability tokens with the existing Pydapter adapter registry.
- Ensure the architecture is future-proof for potential integration with the Lion microkernel.

### 1.3. Non-Goals
- Implementation details of specific cryptographic algorithms (will refer to industry standards).
- A full threat modeling exercise (though common threats will be considered in the design).
- UI/UX design for managing capabilities or policies.
- Specific implementation of the Lion microkernel.

### 1.4. Glossary
- **IsolatedAdapter:** A Pydapter adapter variant that operates within strict security boundaries, requiring explicit capabilities to perform actions.
- **Capability:** A non-forgeable token or data structure that grants specific permissions to an `IsolatedAdapter` to perform a defined set of operations on a specific resource or set of resources.
- **Capability Token:** The digital representation of a capability.
- **CBAC (Capability-Based Access Control):** An access control model where access rights are represented by capabilities.
- **Trust Zone:** A logical grouping of agents, services, or adapters that share a common level of trust and security policies.
- **Principal:** An entity (agent, user, service) that can be granted capabilities.
- **Resource:** An object or service that an `IsolatedAdapter` might interact with (e.g., an API endpoint, a file, a database table).
- **Policy Enforcement Point (PEP):** The component responsible for validating capabilities and enforcing security policies before an action is allowed.
- **Policy Decision Point (PDP):** The component responsible for evaluating policies and issuing capability tokens. (This might be a centralized service or embedded logic).
- **Audit Trail:** A chronological record of security-relevant events.

## 2. Current Pydapter Architecture Context (from TDS-147)

### 2.1. Key Pydapter Concepts
- **Service-as-Orchestrator:** Khive services delegate tasks to Pydapter adapters.
- **Adapter Registry:** A central mechanism for registering and discovering adapters via `obj_key`.
- **`AsyncAdaptable`:** Pydapter mixin used by services to call adapters.
- **`HttpApiAdapter`:** A generic adapter for calling RESTful APIs, configured via `HttpApiAdapterConfig`.

### 2.2. Security Gaps in Current Pydapter Integration (TDS-147)
- [`TDS-147.md#6-security-considerations`](./TDS-147.md#6-security-considerations) notes that API keys are handled by `EndpointConfig` and Pydapter's capability-based security is not yet leveraged.
- Trust is currently managed at the service/configuration level, meaning any adapter loaded by a service implicitly has the service's permissions.
- No fine-grained control over what specific operations an adapter can perform beyond what its configuration allows.
- Lack of standardized audit logging for adapter invocations from a security perspective.

## 3. Proposed `IsolatedAdapter` Security Architecture

### 3.1. Core Principles
- **Principle of Least Privilege:** `IsolatedAdapter`s should only be granted the minimum capabilities necessary to perform their intended functions.
- **Explicit Authorization:** All actions performed by an `IsolatedAdapter` must be explicitly authorized by a capability.
- **Secure by Default:** Adapters should operate in an isolated, low-privilege mode unless explicitly granted capabilities.
- **Verifiability:** All capability grants and security-relevant actions must be auditable.
- **Composability:** Security policies and capabilities should be composable to support complex agent interactions.
- **Performance Consciousness:** Security checks should be efficient to minimize runtime overhead.

### 3.2. `IsolatedAdapter` Definition
The `IsolatedAdapter` will be a specialized version or wrapper around standard Pydapter adapters. It will not directly execute its core logic but will first pass through a security enforcement layer.

```python
# Conceptual representation
# from pydapter.adapters import AsyncAdapter
# from typing import Any, Generic, TypeVar
#
# InputType = TypeVar("InputType")
# OutputType = TypeVar("OutputType")
#
# class CapabilityContext(BaseModel):
#     principal_id: str # ID of the agent/service invoking
#     capability_token: str # The presented capability token
#     # Other relevant context for policy decisions
#
# class IsolatedAdapter(Generic[InputType, OutputType]):
#     def __init__(self, underlying_adapter: AsyncAdapter[InputType, OutputType], policy_enforcement_point: PolicyEnforcementPoint):
#         self._underlying_adapter = underlying_adapter
#         self._pep = policy_enforcement_point
#
#     async def execute(self, data: InputType, cap_context: CapabilityContext, **kwargs) -> OutputType:
#         # 1. PEP validates capability_token against the requested operation on underlying_adapter
#         # This might involve checking the 'obj_key' of the underlying_adapter, the 'data' input,
#         # and the specific method being implicitly called (e.g., from_obj).
#         await self._pep.authorize(
#             capability_token=cap_context.capability_token,
#             principal_id=cap_context.principal_id,
#             requested_action=self._derive_action_from_adapter(data, **kwargs), # e.g. "execute:khive:info:search:perplexity"
#             resource_details=self._get_resource_details() # e.g. {"type": "api_call", "target_url": ...}
#         )
#
#         # 2. If authorized, execute the underlying adapter's logic
#         # The underlying adapter might need to be instantiated or configured based on the capability.
#         # For instance, a capability might contain short-lived credentials.
#         # This implies the underlying_adapter might be a factory or needs re-configuration per call.
#         # Or, the capability itself is for a pre-configured adapter instance.
#
#         # Assuming underlying_adapter is ready to use:
#         result = await self._underlying_adapter.from_obj(data, **kwargs) # Or other relevant method
#
#         # 3. Audit logging (handled by PEP or a dedicated audit service)
#         await self._pep.audit_log_success(cap_context, self._derive_action_from_adapter(data, **kwargs), result)
#
#         return result
#
#     def _derive_action_from_adapter(self, data: Any, **kwargs) -> str:
#         # Logic to determine the specific action being requested
#         # e.g., "execute_adapter:obj_key_of_underlying_adapter"
#         # This needs to be standardized.
#         if hasattr(self._underlying_adapter, 'obj_key'):
#             return f"execute:{self._underlying_adapter.obj_key}"
#         return f"execute:{self._underlying_adapter.__class__.__name__}"
#
#     def _get_resource_details(self) -> dict:
#         # Extract relevant details from the underlying adapter's config for resource identification
#         if isinstance(self._underlying_adapter, HttpApiAdapter): # from TDS-147
#             return {
#                 "type": "HttpApiAdapter",
#                 "base_url": str(self._underlying_adapter.config.base_url),
#                 "endpoint": self._underlying_adapter.config.endpoint,
#                 "method": self._underlying_adapter.config.method
#             }
#         return {"type": self._underlying_adapter.__class__.__name__}
#
#     async def aclose(self):
#         if hasattr(self._underlying_adapter, 'aclose'):
#             await self._underlying_adapter.aclose()

```
**Key characteristics:**
- Wraps an existing Pydapter `AsyncAdapter`.
- Intercepts calls to the underlying adapter.
- Requires a `CapabilityContext` (containing a `CapabilityToken`) for every operation.
- Delegates authorization to a `PolicyEnforcementPoint (PEP)`.
- The `PEP` is responsible for validating the token and logging the action.

### 3.3. Capability-Based Access Control (CBAC) System

#### 3.3.1. Capability Token Definition
A Capability Token will be a structured, verifiable data object, likely a JSON Web Token (JWT) or a similar signed data structure. (pplx:d28a0b3e-7c4a-4f0d-8e2f-5b1c9a7f0e3d - JWT for capabilities)

**Token Payload (Example Fields):**
```json
{
  "jti": "unique_token_id", // JWT ID
  "iss": "khive_pdp_service_url", // Issuer (Policy Decision Point)
  "sub": "principal_id_or_agent_id", // Subject (who is granted the capability)
  "aud": "khive_resource_server_or_adapter_type", // Audience (what this capability is for)
  "exp": "timestamp_expiry", // Expiration time
  "nbf": "timestamp_not_before", // Not before time
  "iat": "timestamp_issued_at", // Issued at time
  "cap": { // Capability-specific claims
    "version": "1.0",
    "action": [
        "execute:khive:info:search:perplexity", // Specific action allowed, e.g., execute adapter with obj_key
        "read:file:/shared/data/*"
    ],
    "resource_constraints": { // Optional: finer-grained constraints on the resource
      "khive:info:search:perplexity": {
        "allowed_queries_regex": "^(weather|news).*", // Example: only allow certain query types
        "max_requests_per_minute": 10
      },
      "file:/shared/data/*": {
          "max_read_bytes": 10240
      }
    },
    "delegable": false, // Can this capability be delegated?
    "scope": "specific_scope_if_any", // e.g., project_id
    "metadata": { /* additional context */ }
  }
}
```
- **`iss` (Issuer):** Identifies the PDP that issued the token.
- **`sub` (Subject):** The principal (agent, user, service) to whom the capability is granted.
- **`aud` (Audience):** The resource or service for which the capability is valid (e.g., a specific adapter `obj_key`, a resource type like "file_system_access").
- **`exp` (Expiration Time):** Capabilities should be short-lived to reduce the impact of token compromise.
- **`cap.action`:** A list of specific actions the principal is allowed to perform (e.g., `execute_adapter`, `read_file`, `write_to_vector_db`). Actions should be namespaced and granular. Example: `adapter:execute:<obj_key>`, `datastore:read:<table_name>`.
- **`cap.resource_constraints`:** Defines specific limitations on the action for the given resource (e.g., rate limits, query patterns, field access).
- **`cap.delegable`:** Boolean indicating if the subject can delegate this capability (or a subset of it) to another principal.

**Token Format and Security:**
- Tokens will be signed using asymmetric cryptography (e.g., ES256) by the PDP. The public key will be available to PEPs for signature verification. (pplx:7f2b9f3a-bef2-431b-b692-8f076146c93e)
- Tokens should be transmitted securely (e.g., via HTTPS, or within secure inter-process communication). (pplx:7f2b9f3a-bef2-431b-b692-8f076146c93e)

#### 3.3.2. Capability Issuance (Policy Decision Point - PDP)
- A central (or distributed) PDP service will be responsible for issuing capability tokens.
- Agents/services request capabilities from the PDP based on their identity and the desired operation.
- The PDP evaluates the request against defined security policies (see Section 3.4) associated with the principal, resource, and action.
- If the policy allows, the PDP mints and signs a capability token.
- The PDP itself needs to be highly secured.

#### 3.3.3. Capability Validation (Policy Enforcement Point - PEP)
- The PEP is integrated with the `IsolatedAdapter` or the Pydapter registry.
- **Steps for Validation:**
    1. **Token Integrity & Authenticity:** Verify the token's signature using the PDP's public key.
    2. **Standard Claims:** Check `exp`, `nbf`, `iss`, `aud`.
    3. **Action Authorization:** Ensure the requested action (e.g., executing a specific adapter method with certain parameters) is present in the `cap.action` list.
    4. **Resource Matching:** Verify that the target resource of the adapter matches the audience or resource specifications in the token.
    5. **Constraint Enforcement:** Evaluate any `cap.resource_constraints` against the current request. For example, if an adapter is about to make an API call, the PEP could check if the target URL or parameters match constraints in the token.
- If validation fails at any step, the action is denied, and an audit log is generated.

### 3.4. Agent-Aware Security Policies and Trust Zones

#### 3.4.1. Security Policies
Policies define "who can do what on which resources under what conditions."
- **Policy Structure (Example):**
  ```yaml
  policies:
    - id: "policy_agent_x_can_search_perplexity"
      description: "Allows Agent X to use the Perplexity search adapter for news queries."
      effect: "allow" # allow | deny
      principals: # Who this policy applies to
        - "agent_type:research_assistant"
        - "agent_id:agent_x_123"
      actions: # What actions are covered
        - "execute:khive:info:search:perplexity"
      resources: # Which resources are targeted (can be specific obj_keys or patterns)
        - "khive:info:search:perplexity"
      conditions: # Further constraints
        - type: "string_match"
          target: "request.query_parameters.q" # Path to the relevant data in the request
          pattern: "^news:.*"
        - type: "rate_limit"
          limit: "10/minute"
      obligations: # Actions to take on allow/deny (e.g., specific audit level)
        - on_allow: { log_level: "DETAILED" }
  ```
- Policies will be managed centrally and loaded by the PDP.
- Policy language could be based on existing standards (e.g., simplified Rego/OPA, or a custom DSL).

#### 3.4.2. Trust Zones
Trust Zones are logical groupings that simplify policy management. An agent or service belongs to one or more trust zones.
- **Example Zones:**
    - `Zone_Untrusted`: External agents, minimal capabilities by default.
    - `Zone_InternalTools`: Khive's own vetted tools, more permissive but still capability-bound.
    - `Zone_CoreServices`: Critical Khive services, highest trust, but still operate with capabilities for internal consistency and auditability.
    - `Zone_UserDataAccess`: Adapters that handle sensitive user data, requiring specific data-access capabilities.
- Capabilities can be granted based on trust zone membership. For example, all agents in `Zone_InternalTools` might automatically get a baseline set of capabilities.
- Interactions *between* trust zones will be strictly controlled by policies, often requiring more scrutiny or specific "gateway" adapters that mediate access.

### 3.5. Runtime Security Validation and Performance
- **PEP Location:** The PEP logic can be:
    1. A sidecar proxy for each service.
    2. A library integrated directly into the Pydapter invocation path (preferred for Khive, as `IsolatedAdapter` suggests).
- **Caching:** (pplx:4356ad0e-a98d-4b78-a91a-4166e908fd23 - emphasizes caching for PDP/PEP)
    - Validated capability tokens (or their validation results) can be cached by the PEP for their lifetime to avoid repeated cryptographic operations and policy lookups for the same token and request pattern. (pplx:c5a3b0f1-1e2a-4b7d-8d9f-2a1e3c0b4a5e - capability caching)
    - PDP's public keys for signature verification should be cached by PEPs.
    - Policy decisions or compiled policy fragments can also be cached at the PEP to reduce latency to the PDP, especially if using a sidecar-like PDP or a highly responsive local PEP cache.
- **Efficient Policy Evaluation:** The policy language and engine must be optimized for speed. Pre-compiled policies or indexed lookups can be used. Centralized management of policies is key for consistency. (pplx:4356ad0e-a98d-4b78-a91a-4166e908fd23)
- **Asynchronous Operations:** All security checks (especially if involving network calls to a remote PDP or for fetching policy updates) must be asynchronous to avoid blocking the event loop.
- **Sampling for Auditing:** For high-throughput adapters, audit logging might use sampling for non-critical events, but security-denials must always be logged.

### 3.6. Audit Logging and Isolation Mechanisms

#### 3.6.1. Audit Trail Format
Audit logs are crucial for security monitoring, incident response, and compliance.
- **Log Structure (JSON):**
  ```json
  {
    "timestamp": "iso_8601_datetime_utc",
    "event_id": "uuid",
    "event_type": "AUTHORIZATION_SUCCESS | AUTHORIZATION_FAILURE | ACTION_EXECUTED",
    "principal": {
      "id": "agent_x_123",
      "type": "research_agent",
      "trust_zones": ["Zone_InternalTools"]
    },
    "action": "execute:khive:info:search:perplexity",
    "resource": {
      "type": "HttpApiAdapter",
      "obj_key": "khive:info:search:perplexity",
      "details": { /* e.g., URL, method */ }
    },
    "capability_token_id": "jti_of_the_token_used", // or hash of token
    "policy_ids_evaluated": ["policy_agent_x_can_search_perplexity"],
    "outcome": "allow | deny",
    "denial_reason": "capability_expired | signature_invalid | action_not_permitted | constraints_violated", // if outcome is deny
    "request_details": { /* sanitized parameters of the request to the adapter */ },
    "response_summary": { /* e.g., status_code, result_size, if applicable and not sensitive */ },
    "pep_id": "pep_instance_identifier",
    "source_ip": "ip_address_of_caller" // if applicable
  }
  ```
- **Key Information:** What, who, when, where, on what resource, using which capability, and what was the outcome.
- **Sanitization:** Sensitive data in `request_details` or `response_summary` must be masked or omitted.

#### 3.6.2. Audit Log Storage and Management
- **Storage:** Dedicated secure logging service (e.g., Elasticsearch, Splunk, or a cloud-native logging solution).
- **Transmission:** Logs should be shipped securely and reliably from PEPs to the central logging system.
- **Retention:** Policies for log retention based on compliance and operational needs.
- **Analysis:** Tools for searching, analyzing, and alerting on audit logs.

#### 3.6.3. Isolation Mechanisms
- **Process/Container Isolation:** If adapters or agents run as separate processes/containers (future Lion microkernel), OS-level isolation is key.
- **Logical Isolation (within a service):** The `IsolatedAdapter` pattern provides logical isolation. The underlying adapter code *cannot* bypass the PEP.
- **Resource Quotas/Limits:** Capabilities can enforce resource usage limits (e.g., CPU time, memory, network bandwidth per call or per time window), though this might be more relevant at the Lion microkernel level. For now, `resource_constraints` in capabilities can enforce application-level limits (e.g., max API calls).
- **Data Flow Control:** Capabilities define allowed data flows. An adapter granted a capability to call API X cannot then arbitrarily write that data to Database Y unless it has a separate capability for that.

### 3.7. Integration with Pydapter Adapter Registry

#### 3.7.1. Registering `IsolatedAdapter`s
- The Pydapter registry ([`TDS-147.md#34-adapter-registry-and-discovery`](./TDS-147.md#3.4.-Adapter-Registry-and-Discovery)) currently registers adapter *factories*.
- For `IsolatedAdapter`s, the registry could:
    1. **Store `IsolatedAdapter` factories directly:** The factory would create the underlying adapter and wrap it with an `IsolatedAdapter` instance, injecting the PEP.
       ```python
       # async def isolated_perplexity_search_adapter_factory() -> IsolatedAdapter:
       #     underlying_factory = perplexity_search_adapter_factory # from TDS-147
       #     underlying_adapter = await underlying_factory()
       #     pep_instance = get_global_pep() # Get a PEP instance
       #     return IsolatedAdapter(underlying_adapter, pep_instance)
       #
       # khive_adapter_registry.register(
       #     isolated_perplexity_search_adapter_factory,
       #     obj_key="secure:khive:info:search:perplexity" # Note: potentially a different obj_key namespace
       # )
       ```
    2. **Wrap at Invocation Time:** The `AsyncAdaptable.adapt_from_async` method (or a new secure variant like `secure_adapt_from_async`) could be modified. When an adapter is retrieved from the registry, if it's marked as requiring isolation (e.g., via metadata in the registry or naming convention of `obj_key`), it's automatically wrapped in an `IsolatedAdapter` before execution. This is more transparent.

#### 3.7.2. `obj_key` and Capability Mapping
- The `obj_key` used to retrieve an adapter from the registry becomes a primary identifier for the "resource" in capability tokens and policies.
- `cap.action` could be `execute:<obj_key>`.
- The `IsolatedAdapter`'s `_derive_action_from_adapter` method would use the `obj_key` of its underlying adapter.

#### 3.7.3. Service Layer Interaction
The service (e.g., `InfoService`) needs to be modified to provide the `CapabilityContext`.

```python
# class InfoService(BaseModel, AsyncAdaptable): # (from TDS-147)
#     # ...
#     async def handle_secure_request(self, request: InfoRequest, calling_agent_token: str) -> InfoResponse:
#         # 1. Authenticate calling_agent_token (if it's an agent identity token)
#         # 2. Request a capability token from PDP for the desired operation
#         #    (This step might be complex: the service acts as a principal requesting on behalf of the agent,
#         #     or the agent provides a capability token directly)
#         # For simplicity, assume capability_token is obtained or provided:
#         capability_token_for_perplexity = await self._pdp_client.request_capability(
#             principal_id=request.agent_id, # or service's own ID
#             action=f"execute:khive:info:search:perplexity",
#             resource_constraints={"allowed_queries_regex": ".*"} # Example
#         )
#
#         cap_context = CapabilityContext(
#             principal_id=request.agent_id, # ID of the original requester
#             capability_token=capability_token_for_perplexity
#         )
#
#         if request.action == InfoAction.SEARCH:
#             adapter_key = f"khive:info:search:{request.params.provider.value.lower()}" # This is the underlying adapter's key
#
#             # The adapt_from_async (or a new secure_adapt_from_async) needs to handle IsolatedAdapter execution
#             # This implies the registry or adapt_from_async itself is aware of the isolation requirement.
#             # One way: adapt_from_async looks up adapter_key, gets underlying_adapter_factory,
#             # creates underlying_adapter, wraps it in IsolatedAdapter, then calls isolated_adapter.execute().
#
#             adapted_response = await self.adapt_from_async( # This method needs to be capability-aware
#                 request.params.provider_params,
#                 obj_key=adapter_key,
#                 # Pass capability context somehow, Pydapter might need extension
#                 # or adapt_from_async is overloaded/specialized
#                 capability_context=cap_context # NEW parameter
#             )
#             return InfoResponse(success=True, content=adapted_response)
#         # ...
```
This implies that Pydapter's `AsyncAdaptable` or the registry lookup mechanism needs to be enhanced to:
1. Accept `capability_context`.
2. Potentially wrap the resolved adapter from the registry with `IsolatedAdapter` if it's not already an isolated one.

A simpler approach for services might be to directly look up an `IsolatedAdapter` factory from the registry using a distinct `obj_key` (e.g., `secure:khive:info:search:perplexity`) and then call its `execute` method.

### 3.8. Compatibility with Future Lion Microkernel
- **Capabilities as IPC Primitives:** Capability tokens are well-suited for Inter-Process Communication (IPC) in a microkernel architecture. A process (agent/adapter) would present its capability token to the microkernel when requesting an operation on another process or a kernel-managed resource.
- **Microkernel as PDP/PEP:** The Lion microkernel could take on roles of the PDP (issuing capabilities for kernel objects) and PEP (enforcing access to kernel-managed resources and IPC channels).
- **Namespace Alignment:** Action and resource namespaces defined in this TDS should be designed with future kernel objects in mind (e.g., `kernel:ipc:send_message`, `kernel:memory:allocate`).
- **Isolation:** The OS-level isolation provided by a microkernel complements the logical isolation of `IsolatedAdapter`. `IsolatedAdapter` would handle application-level permissions, while the kernel handles system-level ones.

## 4. Data Models and Interfaces (New or Modified)
- **`CapabilityToken` (Payload Structure):** As defined in 3.3.1.
- **`CapabilityContext` (Python Model):**
  ```python
  # from pydantic import BaseModel
  # class CapabilityContext(BaseModel):
  #     principal_id: str
  #     capability_token: str # The JWT string or opaque token
  #     # Potentially other context like source IP, request ID for tracing
  ```
- **`Policy` (Structure):** As defined in 3.4.1.
- **`IsolatedAdapter.execute()` method signature:** `async def execute(self, data: InputType, cap_context: CapabilityContext, **kwargs) -> OutputType:`
- **PEP Interface (Conceptual):**
  ```python
  # class PolicyEnforcementPoint(Protocol):
  #     async def authorize(self, capability_token: str, principal_id: str, requested_action: str, resource_details: dict) -> None:
  #         """Raises an exception if not authorized."""
  #         ...
  #     async def audit_log_success(self, cap_context: CapabilityContext, action: str, result: Any) -> None: ...
  #     async def audit_log_failure(self, cap_context: CapabilityContext, action: str, error: Exception) -> None: ...
  ```
- **PDP Client Interface (Conceptual):**
  ```python
  # class PolicyDecisionPointClient(Protocol):
  #     async def request_capability(self, principal_id: str, action: str, resource_id: Optional[str] = None, constraints: Optional[dict] = None) -> str: # Returns token string
  #         ...
  ```

## 5. Security Considerations (Specific to this Design)
- **Token Replay:** JTI (JWT ID) claim and server-side nonce checking can mitigate replay attacks for certain types of capabilities. Short token expiry is the primary defense.
- **Token Leakage:** Secure transmission (TLS) and storage of tokens is paramount. `HttpOnly` cookies if web-based, secure memory otherwise.
- **PDP Compromise:** If the PDP is compromised, the entire system's security can be undermined. The PDP must be extremely secure, with robust authentication, authorization, and audit trails for itself.
- **PEP Implementation Bugs:** Bugs in PEP logic could lead to incorrect enforcement. Rigorous testing and code review are essential.
- **Capability Revocation:** For long-lived capabilities (which should be rare), a revocation mechanism (e.g., CRLs, OCSP-like checks by PEP to PDP) is needed. Short expiry is simpler.
- **Denial of Service (DoS):** Against PDP (too many token requests) or PEP (complex policy evaluation). Rate limiting and optimized evaluation are needed.
- **Side-Channel Attacks:** If resource constraints are based on sensitive data within the request, care must be taken to avoid leaking information through timing or error messages during PEP validation.

## 6. Testing Strategy
- **Unit Tests:**
    - `IsolatedAdapter`: Mock the PEP and the underlying adapter. Verify that `authorize` is called correctly and that the underlying adapter is invoked/not invoked based on PEP's response.
    - `PEP`: Test token validation logic with valid, invalid, expired, and malformed tokens. Test policy evaluation logic with various scenarios.
    - `PDP Client`: Mock the PDP service to test token request formatting.
- **Integration Tests:**
    - Test the full flow: Service -> PDP Client -> (Mock) PDP -> Service -> `IsolatedAdapter` -> PEP -> Underlying Adapter.
    - Test with various policy configurations and capability grants.
    - Test audit logging to ensure correct information is captured.
- **Security Testing / Penetration Testing:**
    - Attempt to bypass PEP.
    - Forge capability tokens.
    - Test for token replay, leakage.
    - Evaluate policy bypass scenarios.

## 7. Risks and Mitigations

| Risk                                            | Likelihood | Impact | Mitigation                                                                                                                                |
|-------------------------------------------------|------------|--------|-------------------------------------------------------------------------------------------------------------------------------------------|
| Performance overhead of PEP validation          | Medium     | Medium | Efficient PEP implementation, caching of validation results, asynchronous operations. Benchmark critical paths.                               |
| Complexity of managing capabilities and policies| High       | Medium | Good tooling for policy definition, clear documentation, phased rollout of policies. Start with simpler policies.                             |
| PDP becomes a single point of failure/bottleneck| Medium     | High   | Design PDP for high availability and scalability. Consider decentralized PDP approaches for certain use cases if truly necessary.               |
| Difficulty in debugging authorization issues    | Medium     | Medium | Comprehensive and clear audit logs. Tooling to trace capability requests and policy evaluations.                                            |
| Integration with existing Pydapter registry     | Medium     | Medium | Clearly define how `IsolatedAdapter`s are registered and invoked. Choose between explicit registration or transparent wrapping. Prototype early. |
| Scope creep for policy language/engine          | Medium     | Medium | Start with a minimal, well-defined policy language. Evolve based on concrete needs.                                                         |

## 8. Open Questions and Future Considerations
- **Capability Delegation:** Detailed design for how `delegable: true` capabilities are handled. How are constraints inherited or modified upon delegation?
- **Dynamic Policy Updates:** How does the PDP (and subsequently PEPs if they cache policies) receive and apply policy updates without service restarts?
- **Cross-Service Capability Passing:** How do services pass capabilities to each other when orchestrating calls? Does the calling service request a new, more restricted capability for the downstream service?
- **User-Facing Capabilities:** How are capabilities managed when the ultimate principal is an end-user interacting with an agent? (e.g., OAuth flow leading to Khive capability issuance).
- **Granularity of `obj_key` for resources:** Is `obj_key` sufficient, or do we need a more structured resource definition language for policies?
- **Bootstrapping Trust:** How does the very first agent/service get its initial set of capabilities?
- **Secret Management for Adapters:** If capabilities grant access but the adapter still needs an API key (e.g., the capability *allows use* of a pre-configured adapter), how are those underlying secrets managed securely in the context of `IsolatedAdapter`? (Perhaps capabilities can *contain* short-lived secrets, or reference a secure vault).

## 9. Deployment Considerations
- The PDP service needs to be deployed as a highly available and secure component.
- PEP components (libraries or sidecars) will be deployed alongside Khive services.
- Secure channels for communication between services, PEPs, and the PDP.
- Mechanism for distributing PDP public keys to PEPs.
- Centralized audit logging infrastructure.

## 10. Documentation Plan
- Detailed documentation on the CBAC model, capability token structure, and policy language.
- Guides for developers on how to:
    - Create and register `IsolatedAdapter`s.
    - Request and use capabilities.
    - Define security policies.
- Operational guides for managing the PDP, monitoring audit logs, and responding to security events.
- Best practices for secure agent development within Khive.

This TDS provides the foundational design for the `IsolatedAdapter` security architecture. Further details and refinements will emerge during the implementation and prototyping phases.